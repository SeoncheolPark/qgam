% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tuneLearnFast.R
\name{tuneLearnFast}
\alias{tuneLearnFast}
\title{Fast learning rate calibration for the Gibbs posterior}
\usage{
tuneLearnFast(form, data, qu, err = 0.05, multicore = !is.null(cluster),
  cluster = NULL, ncores = detectCores() - 1, paropts = list(),
  control = list(), argGam = NULL)
}
\arguments{
\item{form}{A GAM formula, or a list of formulae. See ?mgcv::gam details.}

\item{data}{A data frame or list containing the model response variable and covariates required by the formula.
By default the variables are taken from environment(formula): typically the environment from which gam is called.}

\item{qu}{The quantile of interest. Should be in (0, 1).}

\item{err}{An upper bound on the error of the estimated quantile curve. Should be in (0, 1). If it is a vector, it should be of the 
same length of \code{qu}. See Fasiolo et al. (2016) for details.}

\item{multicore}{If TRUE the calibration will happen in parallel.}

\item{cluster}{An object of class \code{c("SOCKcluster", "cluster")}. This allowes the user to pass her own cluster,
which will be used if \code{multicore == TRUE}. The user has to remember to stop the cluster.}

\item{ncores}{Number of cores used. Relevant if \code{multicore == TRUE}.}

\item{paropts}{a list of additional options passed into the foreach function when parallel computation is enabled. 
This is important if (for example) your code relies on external data or packages: 
use the .export and .packages arguments to supply them so that all cluster nodes 
have the correct environment set up for computing.}

\item{argGam}{A list of parameters to be passed to \code{mgcv::gam}. This list can potentially include all the arguments listed
in \code{?gam}, with the exception of \code{formula}, \code{family} and \code{data}.}
}
\value{
A list with entries: \itemize{
                  \item{\code{lsig} = a vector containing the values of log(sigma) that minimize the loss function, 
                                      for each quantile.}
                  \item{\code{err} = the error bound used for each quantile. Generally each entry is identical to the
                                     argument \code{err}, but in some cases the function increases it to enhance stabily.}
                  \item{\code{ranges} = the search ranges by the Brent algorithm to find log-sigma, for each quantile. }
                  \item{\code{store} = a list, where the i-th entry is a matrix containing all the locations (1st row) at which
                                       the loss function has been evaluated and its value (2nd row), for the i-th quantile.}
}
}
\description{
The learning rate (sigma) of the Gibbs posterior is tuned using a calibration approach,
             based on boostrapping. Here the loss function is minimized, for each quantile, using a Brent search.
}
\examples{
library(qgam); library(MASS)

###
# Single quantile fit
###
# Calibrate learning rate on a grid
set.seed(5235)
tun <- tuneLearnFast(form = accel~s(times,k=20,bs="ad"), 
                     data = mcycle, 
                     err = 0.05, 
                     qu = 0.2)

# Fit for quantile 0.2 using the best sigma
fit <- qgam(accel~s(times, k=20, bs="ad"), data = mcycle, qu = 0.2,
            err = 0.05, lsig = tun$lsig)

pred <- predict(fit, se=TRUE)
plot(mcycle$times, mcycle$accel, xlab = "Times", ylab = "Acceleration", 
     ylim = c(-150, 80))
lines(mcycle$times, pred$fit, lwd = 1)
lines(mcycle$times, pred$fit + 2*pred$se.fit, lwd = 1, col = 2)
lines(mcycle$times, pred$fit - 2*pred$se.fit, lwd = 1, col = 2) 

###
# Multiple quantile fits
###
# Calibrate learning rate on a grid
quSeq <- c(0.25, 0.5, 0.75)
set.seed(5235)
tun <- tuneLearnFast(form = accel~s(times, k=20, bs="ad"), 
                     data = mcycle, 
                     err = 0.05, 
                     qu = quSeq)

# Fit using estimated sigmas
fit <- mqgam(accel~s(times, k=20, bs="ad"), data = mcycle, qu = quSeq,
             err = 0.05, lsig = tun$lsig)

# Plot fitted quantiles
plot(mcycle$times, mcycle$accel, xlab = "Times", ylab = "Acceleration", 
     ylim = c(-150, 80))
for(iq in quSeq){
  pred <- qdo(fit, iq, predict)
  lines(mcycle$times, pred, col = 2)
}                   
}
\author{
Matteo Fasiolo <matteo.fasiolo@gmail.com>.
}
\references{
Fasiolo, M., Goude, Y., Nedellec, R. and Wood, S. N. (2016). Fast calibrated additive quantile regression. Available at
            \url{https://github.com/mfasiolo/qgam/draft_qgam.pdf}.
}

